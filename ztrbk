#!/usr/bin/env bb

(require '[clojure.edn :as edn]
         '[clojure.string :as str]
         '[clojure.java.io :as io]
         '[babashka.process :as p])

;; === Configuration ===

(def default-config-path "/etc/ztrbk.conf")

(defn load-config
  [path]
  (edn/read-string (slurp path)))

;; === ZFS Operations ===

(defn run-cmd
  [cmd]
  (let [result (p/shell {:out :string :err :string :continue true} cmd)]
    (when-not (zero? (:exit result))
      (throw (ex-info "Command failed" {:cmd cmd :result result})))
    (str/trim (:out result))))

(defn run-cmd-safe
  [cmd]
  (try
    (run-cmd cmd)
    (catch Exception e
      nil)))

(defn list-snapshots
  [dataset]
  (let [output (run-cmd-safe (str "zfs list -H -t snapshot -o name -r " dataset))]
    (if output
      (str/split-lines output)
      [])))

(defn snapshot-exists?
  [snapshot-name]
  (zero? (:exit (p/shell {:continue true :out :string}
                         (str "zfs list -H -t snapshot " snapshot-name)))))

(defn create-snapshot
  [dataset timestamp prefix]
  (let [snapshot-name (str dataset "@" prefix timestamp)]
    (println "Creating snapshot:" snapshot-name)
    (run-cmd (str "zfs snapshot " snapshot-name))
    snapshot-name))

(defn destroy-snapshot
  [snapshot-name]
  (println "Destroying snapshot:" snapshot-name)
  (run-cmd (str "zfs destroy " snapshot-name)))

(defn send-snapshot
  ([snapshot-name remote-dataset ssh-host]
   (send-snapshot snapshot-name remote-dataset ssh-host nil))
  ([snapshot-name remote-dataset ssh-host incremental-base]
   (let [dataset (first (str/split snapshot-name #"@"))
         snapshot (second (str/split snapshot-name #"@"))
         remote-snapshot (str remote-dataset "@" snapshot)

         ;; Check if snapshot already exists on remote
         check-cmd (if ssh-host
                     (str "ssh " ssh-host " zfs list -H -t snapshot " remote-snapshot)
                     (str "zfs list -H -t snapshot " remote-snapshot))
         exists? (zero? (:exit (p/shell {:continue true :out :string} check-cmd)))]

     (when exists?
       (println "Snapshot already exists on remote:" remote-snapshot)
       (throw (ex-info "Remote snapshot exists" {:snapshot remote-snapshot})))

     (println "Sending snapshot:" snapshot-name "to" (or ssh-host "local") remote-dataset)

     (let [send-cmd (if incremental-base
                      (str "zfs send -i " incremental-base " " snapshot-name)
                      (str "zfs send " snapshot-name))
           recv-cmd (if ssh-host
                      (str "ssh " ssh-host " zfs receive -F " remote-dataset)
                      (str "zfs receive -F " remote-dataset))
           full-cmd (str send-cmd " | " recv-cmd)]
       (run-cmd full-cmd)))))

;; === Timestamp Parsing ===

(defn parse-timestamp
  [ts-str]
  (try
    (java.time.LocalDateTime/parse ts-str
                                   (java.time.format.DateTimeFormatter/ofPattern "yyyyMMdd-HHmmss"))
    (catch Exception e
      nil)))

(defn parse-snapshot-timestamp
  [snapshot-name prefix]
  (when-let [snap-part (second (str/split snapshot-name #"@"))]
    (when (str/starts-with? snap-part prefix)
      (let [ts-str (subs snap-part (count prefix))]
        (parse-timestamp ts-str)))))

;; === Retention Policy (Clojure-idiomatic) ===

(defn normalize-preserve-min
  [spec]
  "Normalize preserve_min to a standard format"
  (cond
    (= spec :all) {:type :all}
    (= spec :latest) {:type :latest}
    (= spec :no) {:type :no}
    (keyword? spec) (throw (ex-info "Invalid preserve-min keyword" {:spec spec}))
    (string? spec)
      (when-let [match (re-matches #"(\d+)([hdwmy])" spec)]
        (let [[_ amount unit-char] match
              amount (Integer/parseInt amount)
              unit (case unit-char
                     "h" :hours
                     "d" :days
                     "w" :weeks
                     "m" :months
                     "y" :years)]
          {:type :duration :amount amount :unit unit}))
    (map? spec)
      (let [amount (or (:hours spec)
                       (:days spec)
                       (:weeks spec)
                       (:months spec)
                       (:years spec))
            unit (cond
                   (:hours spec) :hours
                   (:days spec) :days
                   (:weeks spec) :weeks
                   (:months spec) :months
                   (:years spec) :years)]
        (when (and amount unit)
          {:type :duration :amount amount :unit unit}))
    :else nil))

(defn normalize-preserve
  [spec]
  "Normalize preserve spec to standard format"
  (cond
    (= spec :no) nil
    (nil? spec) nil
    (keyword? spec) (throw (ex-info "Invalid preserve keyword" {:spec spec}))
    (map? spec)
      (let [result {}
            result (if-let [h (:hours spec)]
                     (assoc result :hourly h)
                     result)
            result (if-let [d (:days spec)]
                     (assoc result :daily d)
                     result)
            result (if-let [w (:weeks spec)]
                     (assoc result :weekly w)
                     result)
            result (if-let [m (:months spec)]
                     (assoc result :monthly m)
                     result)
            result (if-let [y (:years spec)]
                     (assoc result :yearly y)
                     result)]
        result)
    :else nil))

(defn time-ago
  [duration-amount duration-unit]
  (let [now (java.time.LocalDateTime/now)]
    (case duration-unit
      :hours (.minusHours now duration-amount)
      :days (.minusDays now duration-amount)
      :weeks (.minusWeeks now duration-amount)
      :months (.minusMonths now duration-amount)
      :years (.minusYears now duration-amount))))

(defn get-period-key
  [timestamp period hour-of-day day-of-week]
  "Get a key that groups snapshots by their period"
  (case period
    :hourly [(.getYear timestamp) (.getDayOfYear timestamp) (.getHour timestamp)]
    :daily [(.getYear timestamp) (.getDayOfYear timestamp)]
    :weekly [(.getYear timestamp) (.. timestamp (get java.time.temporal.WeekFields/ISO weekOfWeekBasedYear))]
    :monthly [(.getYear timestamp) (.getMonthValue timestamp)]
    :yearly [(.getYear timestamp)]))

(defn is-daily-backup?
  [timestamp hour-of-day]
  (>= (.getHour timestamp) hour-of-day))

(defn is-weekly-backup?
  [timestamp day-of-week]
  (let [dow-map {:monday 1
                 :tuesday 2
                 :wednesday 3
                 :thursday 4
                 :friday 5
                 :saturday 6
                 :sunday 7}
        target-dow (get dow-map day-of-week 7)
        actual-dow (.getValue (.getDayOfWeek timestamp))]
    (= actual-dow target-dow)))

(defn within-preserve-min?
  [snapshot-ts preserve-min-spec]
  "Check if snapshot falls within preserve_min duration"
  (case (:type preserve-min-spec)
    :all true
    :latest false  ;; handled separately
    :no false
    :duration
      (let [{:keys [amount unit]} preserve-min-spec
            cutoff-time (time-ago amount unit)]
        (.isAfter snapshot-ts cutoff-time))))

(defn apply-btrbk-retention
  [snapshots prefix preserve-min-spec preserve-spec
   hour-of-day day-of-week]
  "Apply btrbk-style retention policy"
  (let [;; Parse snapshot timestamps
        snaps-with-ts (keep (fn [snap]
                              (when-let [ts (parse-snapshot-timestamp snap prefix)]
                                {:snapshot snap :timestamp ts}))
                            snapshots)

        ;; Sort by timestamp (newest first)
        sorted-snaps (reverse (sort-by :timestamp snaps-with-ts))

        ;; First, check preserve_min
        preserved-by-min (if (= (:type preserve-min-spec) :all)
                           (set (map :snapshot snaps-with-ts))
                           (if (= (:type preserve-min-spec) :latest)
                             #{(:snapshot (first sorted-snaps))}
                             (set (map :snapshot
                                    (filter #(within-preserve-min?
                                               (:timestamp %)
                                               preserve-min-spec)
                                      snaps-with-ts)))))

        ;; Then apply preserve policy (if any)
        preserved-by-policy
          (if (or (nil? preserve-spec)
                  (= (:type preserve-min-spec) :all))
            #{}
            (let [now (java.time.LocalDateTime/now)

                  ;; Helper to find snapshots for a period
                  find-for-period
                    (fn [period keep-count]
                      (when keep-count
                        (let [candidates
                                (case period
                                  :hourly snaps-with-ts
                                  :daily (filter #(is-daily-backup? (:timestamp %) hour-of-day)
                                           snaps-with-ts)
                                  :weekly (filter #(and (is-daily-backup? (:timestamp %) hour-of-day)
                                                        (is-weekly-backup? (:timestamp %) day-of-week))
                                            snaps-with-ts)
                                  :monthly (filter #(and (is-daily-backup? (:timestamp %) hour-of-day)
                                                         (is-weekly-backup? (:timestamp %) day-of-week))
                                             snaps-with-ts)
                                  :yearly (filter #(and (is-daily-backup? (:timestamp %) hour-of-day)
                                                        (is-weekly-backup? (:timestamp %) day-of-week))
                                            snaps-with-ts))

                              grouped (group-by #(get-period-key (:timestamp %)
                                                                 period
                                                                 hour-of-day
                                                                 day-of-week)
                                                candidates)

                              ;; Get newest from each period
                              period-keepers (map (fn [[_ snaps]]
                                                    (first (sort-by :timestamp #(compare %2 %1) snaps)))
                                               grouped)

                              ;; Sort by timestamp and take requested count
                              sorted-keepers (reverse (sort-by :timestamp period-keepers))
                              final (if (= keep-count :all)
                                      sorted-keepers
                                      (take keep-count sorted-keepers))]
                          (set (map :snapshot final)))))

                  hourly-preserved (find-for-period :hourly (:hourly preserve-spec))
                  daily-preserved (find-for-period :daily (:daily preserve-spec))
                  weekly-preserved (find-for-period :weekly (:weekly preserve-spec))
                  monthly-preserved (find-for-period :monthly (:monthly preserve-spec))
                  yearly-preserved (find-for-period :yearly (:yearly preserve-spec))]

              (into #{}
                    (concat hourly-preserved
                            daily-preserved
                            weekly-preserved
                            monthly-preserved
                            yearly-preserved))))

        ;; Combine both sets
        all-preserved (into preserved-by-min preserved-by-policy)
        all-snapshot-names (set (map :snapshot snaps-with-ts))
        to-destroy (remove all-preserved all-snapshot-names)]

    {:keep (vec all-preserved)
     :destroy (vec to-destroy)}))

(defn filter-managed-snapshots
  [snapshots prefix]
  (filter #(parse-snapshot-timestamp % prefix) snapshots))

(defn get-timestamp
  []
  (let [now (java.time.LocalDateTime/now)]
    (.format now (java.time.format.DateTimeFormatter/ofPattern "yyyyMMdd-HHmmss"))))

(defn format-preserve-min
  [spec]
  "Format preserve-min for display"
  (cond
    (= spec :all) ":all"
    (= spec :latest) ":latest"
    (= spec :no) ":no"
    (string? spec) spec
    (map? spec)
      (let [[unit amount] (first (filter second spec))]
        (str amount (name unit)))
    :else "unknown"))

(defn format-preserve
  [spec]
  "Format preserve for display"
  (cond
    (= spec :no) ":no"
    (nil? spec) ":no"
    (map? spec)
      (str/join " "
                (keep (fn [[k v]]
                        (when v
                          (str (if (= v :all) "*" v)
                               (case k
                                 :hourly "h"
                                 :daily "d"
                                 :weekly "w"
                                 :monthly "m"
                                 :yearly "y"))))
                      [[:hourly (:hours spec)]
                       [:daily (:days spec)]
                       [:weekly (:weeks spec)]
                       [:monthly (:months spec)]
                       [:yearly (:years spec)]]))
    :else "unknown"))

;; === Volume Configuration ===

(defn process-volume
  [vol-config global-defaults dry-run?]
  (let [{:keys [source snapshot-name snapshot-preserve snapshot-preserve-min]} vol-config
        prefix (or snapshot-name (:snapshot-name global-defaults) "ztrbk_")
        timestamp (get-timestamp)

        ;; Retention settings
        preserve-min-raw (or snapshot-preserve-min
                             (:snapshot-preserve-min global-defaults)
                             :all)
        preserve-raw (or snapshot-preserve
                         (:snapshot-preserve global-defaults)
                         :no)

        preserve-min (normalize-preserve-min preserve-min-raw)
        preserve (normalize-preserve preserve-raw)

        hour-of-day (or (:preserve-hour-of-day vol-config)
                        (:preserve-hour-of-day global-defaults)
                        0)
        day-of-week (or (:preserve-day-of-week vol-config)
                        (:preserve-day-of-week global-defaults)
                        :sunday)

        ;; Create new snapshot
        new-snapshot (when-not dry-run?
                       (create-snapshot source timestamp prefix))

        ;; Get all snapshots
        all-snapshots (list-snapshots source)
        managed (filter-managed-snapshots all-snapshots prefix)

        ;; Apply retention
        {keep-local :keep destroy-local :destroy}
          (apply-btrbk-retention managed
                                 prefix
                                 preserve-min
                                 preserve
                                 hour-of-day
                                 day-of-week)]

    (println "\nVolume:" source)
    (println "  snapshot-preserve-min:" (format-preserve-min preserve-min-raw))
    (println "  snapshot-preserve:" (format-preserve preserve-raw))
    (println "  Keeping" (count keep-local) "local snapshots")
    (println "  Destroying" (count destroy-local) "local snapshots")

    ;; Destroy old snapshots
    (doseq [snap destroy-local]
      (if dry-run?
        (println "  [DRY RUN] Would destroy:" snap)
        (destroy-snapshot snap)))

    {:source source
     :new-snapshot new-snapshot
     :kept-snapshots keep-local
     :prefix prefix
     :hour-of-day hour-of-day
     :day-of-week day-of-week}))

;; === Target/Remote Management ===

(defn find-common-snapshot
  [local-snapshots remote-snapshots prefix]
  (let [local-set (set (map #(second (str/split % #"@")) local-snapshots))
        remote-set (set (map #(second (str/split % #"@")) remote-snapshots))
        common (filter local-set remote-set)]
    (when (seq common)
      (last (sort common)))))

(defn process-target
  [target-config vol-result global-defaults dry-run?]
  (let [{:keys [ssh target target-preserve target-preserve-min]} target-config
        {:keys [source new-snapshot kept-snapshots prefix hour-of-day day-of-week]} vol-result

        ;; Retention settings for target
        preserve-min-raw (or target-preserve-min
                             (:target-preserve-min global-defaults)
                             :all)
        preserve-raw (or target-preserve
                         (:target-preserve global-defaults)
                         :no)

        preserve-min (normalize-preserve-min preserve-min-raw)
        preserve (normalize-preserve preserve-raw)

        target-hour (or (:preserve-hour-of-day target-config) hour-of-day)
        target-day (or (:preserve-day-of-week target-config) day-of-week)

        ;; Get remote snapshots
        remote-list-cmd (if ssh
                          (str "ssh " ssh " zfs list -H -t snapshot -o name -r " target)
                          (str "zfs list -H -t snapshot -o name -r " target))
        remote-output (run-cmd-safe remote-list-cmd)
        remote-snapshots (if remote-output (str/split-lines remote-output) [])
        remote-managed (filter-managed-snapshots remote-snapshots prefix)

        ;; Find incremental base
        common (find-common-snapshot kept-snapshots remote-managed prefix)
        incremental-base (when common (str source "@" common))

        ;; Send new snapshot
        _ (when (and new-snapshot (not dry-run?))
            (try
              (send-snapshot new-snapshot target ssh incremental-base)
              (catch Exception e
                (println "  Error sending snapshot:" (.getMessage e)))))

        ;; Apply retention on remote
        {keep-remote :keep destroy-remote :destroy}
          (apply-btrbk-retention remote-managed
                                 prefix
                                 preserve-min
                                 preserve
                                 target-hour
                                 target-day)]

    (println "\n  Target:" (or ssh "local") target)
    (println "    target-preserve-min:" (format-preserve-min preserve-min-raw))
    (println "    target-preserve:" (format-preserve preserve-raw))
    (println "    Keeping" (count keep-remote) "remote snapshots")
    (println "    Destroying" (count destroy-remote) "remote snapshots")
    (when incremental-base
      (println "    Using incremental base:" incremental-base))

    ;; Destroy old remote snapshots
    (doseq [snap destroy-remote]
      (let [destroy-cmd (if ssh
                          (str "ssh " ssh " zfs destroy " snap)
                          (str "zfs destroy " snap))]
        (if dry-run?
          (println "    [DRY RUN] Would destroy:" snap)
          (do
            (println "    Destroying remote snapshot:" snap)
            (run-cmd destroy-cmd)))))))

;; === Main Processing ===

(defn process-config
  [config dry-run?]
  (let [{:keys [global volumes]} config
        defaults (or global {})]

    (println "=== ztrbk - ZFS Snapshot Manager ===")
    (when dry-run? (println "\n*** DRY RUN MODE ***\n"))

    (doseq [vol-config volumes]
      (try
        (let [vol-result (process-volume vol-config defaults dry-run?)
              targets (:targets vol-config)]

          ;; Process targets/remotes
          (doseq [target targets]
            (try
              (process-target target vol-result defaults dry-run?)
              (catch Exception e
                (println "  Error processing target:" (.getMessage e))))))

        (catch Exception e
          (println "Error processing volume:" (.getMessage e)))))))

;; === CLI ===

(defn print-usage
  []
  (println "Usage: ztrbk [options] <command>")
  (println "")
  (println "Commands:")
  (println "  run        Execute snapshot creation and replication")
  (println "  dryrun     Show what would be done without making changes")
  (println "")
  (println "Options:")
  (println "  -c, --config FILE    Use specified config file (default: /etc/ztrbk.conf)")
  (println "")
  (println "Example config file (EDN format):")
  (println "")
  (println "Clojure-idiomatic retention (using maps):")
  (println "{:global {:snapshot-name \"ztrbk_\"")
  (println "          :preserve-hour-of-day 0")
  (println "          :preserve-day-of-week :sunday")
  (println "          :snapshot-preserve-min :all")
  (println "          :snapshot-preserve :no")
  (println "          :target-preserve-min :all")
  (println "          :target-preserve :no}")
  (println " :volumes")
  (println " [{:source \"tank/data\"")
  (println "   ;; Keep all for 14 days, then tiered")
  (println "   :snapshot-preserve-min {:days 14}")
  (println "   :snapshot-preserve {:days 14 :weeks 8 :months 24}")
  (println "   :targets")
  (println "   [{:target \"backup/data\"")
  (println "     :ssh \"user@backup-host\"")
  (println "     :target-preserve-min {:days 30}")
  (println "     :target-preserve {:days 60 :months :all :years 10}}]}")
  (println "")
  (println "  ;; Simple example: keep only latest")
  (println "  {:source \"tank/temp\"")
  (println "   :snapshot-preserve-min :latest")
  (println "   :snapshot-preserve :no")
  (println "   :targets [{:target \"tank/temp-backup\"")
  (println "              :target-preserve-min :latest")
  (println "              :target-preserve :no}]}]}")
  (println "")
  (println "String format also supported:")
  (println "  :snapshot-preserve-min \"14d\"")
  (println "")
  (println "Preserve min values:")
  (println "  :all               - Keep everything forever (default)")
  (println "  :latest            - Keep only newest snapshot")
  (println "  :no                - Don't keep anything (rely on preserve only)")
  (println "  {:hours N}         - Keep all for N hours")
  (println "  {:days N}          - Keep all for N days")
  (println "  {:weeks N}         - Keep all for N weeks")
  (println "  {:months N}        - Keep all for N months")
  (println "  {:years N}         - Keep all for N years")
  (println "  \"<N>h/d/w/m/y\"     - String format (e.g., \"14d\", \"6w\")")
  (println "")
  (println "Preserve format (map with any combination):")
  (println "  {:hours N}         - Keep N hourly snapshots")
  (println "  {:days N}          - Keep N daily snapshots")
  (println "  {:weeks N}         - Keep N weekly snapshots")
  (println "  {:months N}        - Keep N monthly snapshots")
  (println "  {:years N}         - Keep N yearly snapshots")
  (println "  Use :all for unlimited (e.g., {:months :all})")
  (println "")
  (println "How it works:")
  (println "  1. preserve-min: Keep ALL snapshots within this duration")
  (println "  2. preserve: Keep specific snapshots (hourly/daily/weekly/monthly/yearly)")
  (println "     - Snapshots within preserve-min are already kept")
  (println "     - preserve adds ADDITIONAL snapshots beyond preserve-min")
  (System/exit 1))

(defn -main
  [& args]
  (let [parsed (loop [args args
                      config-path default-config-path
                      command nil]
                 (if-let [arg (first args)]
                   (case arg
                     ("-c" "--config") (recur (drop 2 args) (second args) command)
                     ("run" "dryrun") (recur (rest args) config-path arg)
                     (do
                       (println "Unknown argument:" arg)
                       (print-usage)))
                   {:config-path config-path :command command}))]

    (when-not (:command parsed)
      (print-usage))

    (let [config-path (:config-path parsed)
          command (:command parsed)
          dry-run? (= command "dryrun")]

      (when-not (.exists (io/file config-path))
        (println "Config file not found:" config-path)
        (System/exit 1))

      (try
        (let [config (load-config config-path)]
          (process-config config dry-run?))
        (catch Exception e
          (println "Error:" (.getMessage e))
          (System/exit 1))))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
