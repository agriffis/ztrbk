#!/usr/bin/env bb

(require '[clojure.edn :as edn]
         '[clojure.string :as str]
         '[clojure.java.io :as io]
         '[babashka.process :as p])

;; === Configuration ===

(def default-config-path "/etc/ztrbk.conf")

(defn load-config
  [path]
  (edn/read-string (slurp path)))

;; === ZFS Operations ===

(def _snapshots (atom nil))

(defn fetch-snapshots
  [dataset]
  (let [proc (p/shell {:out :string} "zfs list -H -t snapshot -o name -r" dataset)]
    (->> (str/split-lines (:out proc))
         (remove str/blank?)
         set)))

(defn snapshots
  [dataset]
  (or (get @_snapshots dataset)
      (let [fetched (fetch-snapshots dataset)]
        (swap! _snapshots assoc dataset fetched)
        fetched)))

(defn snapshot-dataset
  [snapshot-name]
  (first (str/split snapshot-name #"@")))

(defn snapshot-rest
  [snapshot-name]
  (second (str/split snapshot-name #"@")))

(defn snapshot-exists?
  [snapshot-name]
  (let [snaps (snapshots (snapshot-dataset snapshot-name))]
    (boolean (snaps snapshot-name))))

(defn create-snapshot
  "Create snapshot if it does not already exist"
  [dataset prefix timestamp]
  (let [snapshot-name (str dataset "@" prefix timestamp)]
    (when (not (snapshot-exists? snapshot-name))
      (p/shell "zfs snapshot" snapshot-name)
      (swap! _snapshots update dataset conj snapshot-name))
    snapshot-name))

(defn destroy-snapshot
  "Destroy snapshot if it exists"
  [snapshot-name]
  (when (snapshot-exists? snapshot-name)
    (p/shell "zfs destroy" snapshot-name)
    (let [dataset (snapshot-dataset snapshot-name)]
      (swap! _snapshots update dataset disj snapshot-name))))

(defn send-snapshot
  "Send snapshot to target dataset, optionally incrementally, if it does not
  already exist"
  ([snapshot-name target-dataset]
   (send-snapshot snapshot-name target-dataset nil))
  ([snapshot-name target-dataset incremental-base]
   (when-not (snapshot-exists? (str target-dataset "@" (snapshot-rest snapshot-name)))
     (let [send-cmd (if incremental-base
                      ["zfs send -w -i" incremental-base snapshot-name]
                      ["zfs send -w" snapshot-name])
           recv-cmd ["zfs receive -e" target-dataset]
           send-proc (apply p/process {:err :inherit} send-cmd)
           recv-proc (apply p/shell {:in (:out send-proc)} recv-cmd)]
       recv-proc))))

;; === Timestamp Parsing ===

;; TODO: add configuration item for this
(def ^:dynamic *timestamp-format-str* "yyyy-MM-dd_HH-mm")

(def timestamp-formatter
  (memoize (fn [format-str]
              (java.time.format.DateTimeFormatter/ofPattern format-str))))

(defn parse-timestamp
  "Attempt to parse timestamp string, returning nil on failure"
  [ts-str]
  (try
    (java.time.LocalDateTime/parse ts-str (timestamp-formatter *timestamp-format-str*))
    (catch Exception _
      nil)))

(defn parse-snapshot-timestamp
  "Attempt to parse timestamp from snapshot name with given prefix, returning
  nil for no match"
  [snapshot-name prefix]
  (when-let [snap-part (snapshot-rest snapshot-name)]
    (when (str/starts-with? snap-part prefix)
      (let [ts-str (subs snap-part (count prefix))]
        (parse-timestamp ts-str)))))

;; === Retention Policy ===

;; TODO: set this at start of processing
(def ^:dynamic *now* nil)

(defn time-ago
  ([duration-amount duration-unit]
   (time-ago duration-amount duration-unit (or *now* java.time.LocalDateTime/now)))
  ([duration-amount duration-unit now]
   (case duration-unit
     :hours (.minusHours now duration-amount)
     :days (.minusDays now duration-amount)
     :weeks (.minusWeeks now duration-amount)
     :months (.minusMonths now duration-amount)
     :years (.minusYears now duration-amount))))

(def units [:hours :days :weeks :months :years])

(defn is-valid-unit?
  [unit-kw]
  (some #{unit-kw} units))

(defn normalize-preserve-min
  "Normalize preserve-min to a standard format"
  [spec]
  (cond
    (= spec :all) {:type :all}
    (= spec :latest) {:type :latest}
    (= spec :no) {:type :no}
    (nil? spec) {:type :all}
    (map? spec)
      (do
        (when (not= 1 (count spec))
          (throw (ex-info "Invalid preserve-min count" {:spec spec})))
        (let [[unit amount] (first spec)]
          (when (not (is-valid-unit? unit))
            (throw (ex-info "Invalid preserve-min unit" {:spec spec})))
          {:type :duration :unit unit :amount amount}))
    :else (throw (ex-info "Invalid preserve-min spec" {:spec spec}))))

(defn normalize-preserve
  "Normalize preserve spec to standard format"
  [spec]
  (cond
    (= spec :no) nil
    (nil? spec) nil
    (map? spec) spec
    :else (throw (ex-info "Invalid preserve spec" {:spec spec}))))

(defn expired?
  "Check if snapshot falls within amount units"
  [snapshot-ts amount unit]
  (let [cutoff-time (time-ago amount unit)]
    (.isAfter cutoff-time snapshot-ts)))

(defn normalize-day-of-week
  "Normalize day-of-week to integer 1-7 (Monday=1, Sunday=7)"
  [spec]
  (cond
    (int? spec) (cond
                  (= spec 0) 7  ; 0 -> Sunday
                  (= spec 7) 7  ; 7 -> Sunday
                  (<= 1 spec 6) spec
                  :else (throw (ex-info "Invalid day-of-week number" {:spec spec})))
    (keyword? spec) (case spec
                      :monday 1
                      :tuesday 2
                      :wednesday 3
                      :thursday 4
                      :friday 5
                      :saturday 6
                      :sunday 7
                      (throw (ex-info "Invalid day-of-week keyword" {:spec spec})))
    :else (throw (ex-info "Invalid day-of-week spec" {:spec spec}))))

(defn normalize-month-of-year
  "Normalize month-of-year to integer 1-12"
  [spec]
  (cond
    (int? spec) (if (<= 1 spec 12)
                  spec
                  (throw (ex-info "Invalid month-of-year number" {:spec spec})))
    (keyword? spec) (case spec
                      :january 1
                      :february 2
                      :march 3
                      :april 4
                      :may 5
                      :june 6
                      :july 7
                      :august 8
                      :september 9
                      :october 10
                      :november 11
                      :december 12
                      (throw (ex-info "Invalid month-of-year keyword" {:spec spec})))
    :else (throw (ex-info "Invalid month-of-year spec" {:spec spec}))))

;; preserve-hour-of-day: hour on which daily backups are taken, 0-23
;; preserve-day-of-week: day on which weekly backups are taken, keyword or 0-7 where 0 and 7 are both sunday
;; preserve-week-of-month: week in which monthly backups are taken, 1-based
;; preserve-month-of-year: month in which yearly backups are taken, keyword or 1-based

(defn get-period-key
  "Get a key for grouping snapshots by period"
  [timestamp unit hour-of-day day-of-week week-of-month month-of-year]
  (let [;; Adjust timestamp so day starts at hour-of-day (for all units except :hours)
        adjusted (if (and (not= unit :hours)
                          (< (.getHour timestamp) hour-of-day))
                   (.minusDays timestamp 1)
                   timestamp)
        ;; Further adjust so month starts at week-of-month (for :months and :years)
        adjusted (if (and (or (= unit :months) (= unit :years))
                          (< (int (Math/ceil (/ (.getDayOfMonth adjusted) 7.0))) week-of-month))
                   (.minusMonths adjusted 1)
                   adjusted)
        ;; Further adjust so year starts at month-of-year (for :years only)
        adjusted (if (and (= unit :years)
                          (< (.getMonthValue adjusted) month-of-year))
                   (.minusYears adjusted 1)
                   adjusted)]
    (case unit
      :hours [(.getYear timestamp)
              (.getMonthValue timestamp)
              (.getDayOfMonth timestamp)
              (.getHour timestamp)]
      :days [(.getYear adjusted)
             (.getMonthValue adjusted)
             (.getDayOfMonth adjusted)]
      :weeks (let [ts-day-of-week (.getValue (.getDayOfWeek adjusted))
                   ;; Calculate days to subtract to get to the target day
                   days-back (mod (+ (- ts-day-of-week day-of-week) 7) 7)
                   week-start (.minusDays adjusted days-back)]
               [(.getYear week-start)
                (.getMonthValue week-start)
                (.getDayOfMonth week-start)])
      :months (let [day-of-month (.getDayOfMonth adjusted)
                    week (int (Math/ceil (/ day-of-month 7.0)))]
                [(.getYear adjusted)
                 (.getMonthValue adjusted)
                 week])
      :years [(.getYear adjusted)])))

(defn apply-retention
  "Apply btrbk-style retention policy"
  [snapshots prefix preserve-min-spec preserve-spec
   hour-of-day day-of-week week-of-month month-of-year]
  (let [;; Parse snapshot timestamps
        snaps-with-ts (keep (fn [snap]
                              (when-let [ts (parse-snapshot-timestamp snap prefix)]
                                {:snapshot snap :timestamp ts}))
                            snapshots)

        ;; Sort by timestamp (newest first)
        snaps-with-ts (reverse (sort-by :timestamp snaps-with-ts))

        ;; First, check preserve-min
        preserved-by-min (case (:type preserve-min-spec)
                           :all (set (map :snapshot snaps-with-ts))
                           :latest #{(:snapshot (first snaps-with-ts))}
                           :no #{}
                           :duration (set (map :snapshot
                                            (remove #(expired?
                                                       (:timestamp %)
                                                       (:amount preserve-min-spec)
                                                       (:unit preserve-min-spec))
                                              snaps-with-ts))))

        ;; Then apply preserve policy (if any)
        preserved-by-policy
          (if (or (nil? preserve-spec)
                  (= (:type preserve-min-spec) :all))
            #{}
            (let [;; Helper to find snapshots for a period
                  find-for-unit
                    (fn [unit]
                      (let [amount (or (preserve-spec unit) 0)
                            unexpired (if (= :all amount)
                                        snaps-with-ts
                                        (take-while #(not (expired? (:timestamp %)
                                                                    amount
                                                                    unit))
                                                    snaps-with-ts))
                            grouped (group-by #(get-period-key (:timestamp %)
                                                               unit
                                                               hour-of-day
                                                               day-of-week
                                                               week-of-month
                                                               month-of-year)
                                              unexpired)
                            keepers (map (fn [[_ snaps]]
                                           (first (sort-by :timestamp compare snaps)))
                                      grouped)]
                        (map :snapshot keepers)))]
              (into #{} (mapcat find-for-unit units))))

        ;; Combine both sets
        all-preserved (into preserved-by-min preserved-by-policy)
        all-snapshot-names (set (map :snapshot snaps-with-ts))
        to-destroy (remove all-preserved all-snapshot-names)]

    {:keep (vec (sort all-preserved))
     :destroy (vec (sort to-destroy))}))

(defn filter-managed-snapshots
  [snapshots prefix]
  (filter #(parse-snapshot-timestamp % prefix) snapshots))

;; === Volume Configuration ===

(defn process-volume
  [vol-config global-defaults dry-run?]
  (let [{:keys [source prefix snapshot-preserve snapshot-preserve-min]} vol-config
        prefix (or prefix (:prefix global-defaults) "ztrbk_")
        timestamp
          (.format timestamp-formatter (or *now* (java.time.LocalDateTime/now)))

        ;; Retention settings
        preserve-min-raw (or snapshot-preserve-min
                             (:snapshot-preserve-min global-defaults)
                             :all)
        preserve-raw (or snapshot-preserve
                         (:snapshot-preserve global-defaults)
                         :no)

        preserve-min (normalize-preserve-min preserve-min-raw)
        preserve (normalize-preserve preserve-raw)

        hour-of-day (or (:preserve-hour-of-day vol-config)
                        (:preserve-hour-of-day global-defaults)
                        0)
        day-of-week (normalize-day-of-week
                      (or (:preserve-day-of-week vol-config)
                          (:preserve-day-of-week global-defaults)
                          :sunday))
        week-of-month (or (:preserve-week-of-month vol-config)
                          (:preserve-week-of-month global-defaults)
                          1)
        month-of-year (normalize-month-of-year
                        (or (:preserve-month-of-year vol-config)
                            (:preserve-month-of-year global-defaults)
                            :january))

        ;; Create new snapshot
        new-snapshot (when-not dry-run?
                       (create-snapshot source prefix timestamp))

        ;; Get all snapshots
        all-snapshots (snapshots source)
        managed (filter-managed-snapshots all-snapshots prefix)

        ;; Apply retention
        {keep-local :keep destroy-local :destroy}
          (apply-retention managed
                           prefix
                           preserve-min
                           preserve
                           hour-of-day
                           day-of-week
                           week-of-month
                           month-of-year)]

    (println "\nVolume:" source)
    (println "  snapshot-preserve-min:" (format-preserve-min preserve-min-raw))
    (println "  snapshot-preserve:" (format-preserve preserve-raw))
    (println "  Keeping" (count keep-local) "local snapshots")
    (println "  Destroying" (count destroy-local) "local snapshots")

    ;; Destroy old snapshots
    (doseq [snap destroy-local]
      (if dry-run?
        (println "  [DRY RUN] Would destroy:" snap)
        (destroy-snapshot snap)))

    {:source source
     :new-snapshot new-snapshot
     :kept-snapshots keep-local
     :prefix prefix
     :hour-of-day hour-of-day
     :day-of-week day-of-week}))

;; === Target/Remote Management ===

(defn find-common-snapshot
  [local-snapshots target-snapshots]
  (let [local-set (set (map snapshot-rest local-snapshots))
        target-set (set (map snapshot-rest target-snapshots))
        common (filter local-set target-set)]
    (when (seq common)
      (last (sort common)))))

(defn process-target
  [target-config vol-result global-defaults dry-run?]
  (let [{:keys [target target-preserve target-preserve-min]} target-config
        {:keys [source new-snapshot kept-snapshots prefix hour-of-day day-of-week]} vol-result

        ;; Retention settings for target
        preserve-min-raw (or target-preserve-min
                             (:target-preserve-min global-defaults)
                             :all)
        preserve-raw (or target-preserve
                         (:target-preserve global-defaults)
                         :no)

        preserve-min (normalize-preserve-min preserve-min-raw)
        preserve (normalize-preserve preserve-raw)

        target-hour (or (:preserve-hour-of-day target-config) hour-of-day)
        target-day (or (:preserve-day-of-week target-config) day-of-week)

        ;; Get target snapshots
        target-snapshots (snapshots target)
        target-managed (filter-managed-snapshots target-snapshots prefix)

        ;; Find incremental base
        common (find-common-snapshot kept-snapshots target-managed)
        incremental-base (when common (str source "@" common))

        ;; Send new snapshot
        ;; TODO: should this depend on retention policy?
        _ (when (and new-snapshot (not dry-run?))
            (try
              (send-snapshot new-snapshot target incremental-base)
              (catch Exception e
                (println "  Error sending snapshot:" (.getMessage e)))))

        ;; Apply retention on target
        {keep-target :keep destroy-target :destroy}
          (apply-retention target-managed
                           prefix
                           preserve-min
                           preserve
                           target-hour
                           target-day)]

    (println "\n  Target:" target)
    (println "    target-preserve-min:" (format-preserve-min preserve-min-raw))
    (println "    target-preserve:" (format-preserve preserve-raw))
    (println "    Keeping" (count keep-target) "target snapshots")
    (println "    Destroying" (count destroy-target) "target snapshots")
    (when incremental-base
      (println "    Using incremental base:" incremental-base))

    ;; Destroy old target snapshots
    (doseq [snap destroy-target]
      (if dry-run?
        (println "    [DRY RUN] Would destroy:" snap)
        (destroy-snapshot snap)))))

;; === Main Processing ===

(defn process-config
  [config dry-run?]
  (let [{:keys [global volumes]} config
        defaults (or global {})]

    (println "=== ztrbk - ZFS Snapshot Manager ===")
    (when dry-run? (println "\n*** DRY RUN MODE ***\n"))

    (doseq [vol-config volumes]
      (try
        (let [vol-result (process-volume vol-config defaults dry-run?)
              targets (:targets vol-config)]

          ;; Process targets
          (doseq [target targets]
            (try
              (process-target target vol-result defaults dry-run?)
              (catch Exception e
                (println "  Error processing target:" (.getMessage e))))))

        (catch Exception e
          (println "Error processing volume:" (.getMessage e)))))))

;; === CLI ===

(defn print-usage
  []
  (println "Usage: ztrbk [options] <command>")
  (println "")
  (println "Commands:")
  (println "  run        Execute snapshot creation and replication")
  (println "  dryrun     Show what would be done without making changes")
  (println "")
  (println "Options:")
  (println "  -c, --config FILE    Use specified config file (default: /etc/ztrbk.conf)")
  (println "")
  (println "Example config file (EDN format):")
  (println "")
  (println "{:global {:prefix \"ztrbk_\"")
  (println "          :preserve-hour-of-day 0")
  (println "          :preserve-day-of-week :sunday")
  (println "          :snapshot-preserve-min :all")
  (println "          :snapshot-preserve :no")
  (println "          :target-preserve-min :all")
  (println "          :target-preserve :no}")
  (println " :volumes")
  (println " [{:source \"tank/data\"")
  (println "   ;; Keep all for 14 days, then tiered")
  (println "   :snapshot-preserve-min {:days 14}")
  (println "   :snapshot-preserve {:days 14 :weeks 8 :months 24}")
  (println "   :targets")
  (println "   [{:target \"backup/data\"")
  (println "     :target-preserve-min {:days 30}")
  (println "     :target-preserve {:days 60 :months :all :years 10}}]}")
  (println "")
  (println "  ;; Simple example: keep only latest")
  (println "  {:source \"tank/temp\"")
  (println "   :snapshot-preserve-min :latest")
  (println "   :snapshot-preserve :no")
  (println "   :targets [{:target \"tank/temp-backup\"")
  (println "              :target-preserve-min :latest")
  (println "              :target-preserve :no}]}]}")
  (println "")
  (println "Preserve min values:")
  (println "  :all               - Keep everything forever (default)")
  (println "  :latest            - Keep only newest snapshot")
  (println "  :no                - Don't keep anything (rely on preserve only)")
  (println "  {:hours N}         - Keep all for N hours")
  (println "  {:days N}          - Keep all for N days")
  (println "  {:weeks N}         - Keep all for N weeks")
  (println "  {:months N}        - Keep all for N months")
  (println "  {:years N}         - Keep all for N years")
  (println "")
  (println "Preserve format (map with any combination):")
  (println "  {:hours N}         - Keep N hourly snapshots")
  (println "  {:days N}          - Keep N daily snapshots")
  (println "  {:weeks N}         - Keep N weekly snapshots")
  (println "  {:months N}        - Keep N monthly snapshots")
  (println "  {:years N}         - Keep N yearly snapshots")
  (println "  Use :all for unlimited (e.g., {:months :all})")
  (println "")
  (println "How it works:")
  (println "  1. preserve-min: Keep ALL snapshots within this duration")
  (println "  2. preserve: Keep specific snapshots (hourly/daily/weekly/monthly/yearly)")
  (println "     - Snapshots within preserve-min are already kept")
  (println "     - preserve adds ADDITIONAL snapshots beyond preserve-min")
  (System/exit 1))

(defn -main
  [& args]
  (let [parsed (loop [args args
                      config-path default-config-path
                      command nil]
                 (if-let [arg (first args)]
                   (case arg
                     ("-c" "--config") (recur (drop 2 args) (second args) command)
                     ("run" "dryrun") (recur (rest args) config-path arg)
                     (do
                       (println "Unknown argument:" arg)
                       (print-usage)))
                   {:config-path config-path :command command}))]

    (when-not (:command parsed)
      (print-usage))

    (let [config-path (:config-path parsed)
          command (:command parsed)
          dry-run? (= command "dryrun")]

      (when-not (.exists (io/file config-path))
        (println "Config file not found:" config-path)
        (System/exit 1))

      (try
        (let [config (load-config config-path)]
          (process-config config dry-run?))
        (catch Exception e
          (println "Error:" (.getMessage e))
          (System/exit 1))))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
